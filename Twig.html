    <HTML> 
	<HEAD> 
	    <TITLE>XML::Twig - A perl module for processing huge XML documents in tree mode.

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#METHODS">METHODS</A>
	<UL>

		<LI><A HREF="#Twigs">Twigs </A>
		<LI><A HREF="#Element">Element</A>
		<LI><A HREF="#Entity_list">Entity_list</A>
		<LI><A HREF="#Entity">Entity</A>
	</UL>

	<LI><A HREF="#EXAMPLES">EXAMPLES</A>
	<LI><A HREF="#NOTES">NOTES</A>
	<UL>

		<LI><A HREF="#DTD_Handling">DTD Handling</A>
		<LI><A HREF="#Whitespace_Handling">Whitespace Handling</A>
		<LI><A HREF="#Flush">Flush</A>
	</UL>

	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#TODO">TODO </A>
	<LI><A HREF="#BENCHMARKS">BENCHMARKS</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME

</A></H1>
XML::Twig - A perl module for processing huge XML documents in tree mode.


<P>

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS

</A></H1>
<PRE>    single-tree mode    
        my $t= new XML::Twig();
        $t-&gt;parse( '&lt;doc&gt;&lt;para&gt;para1&lt;/para&gt;&lt;/doc&gt;');
        $t-&gt;print;
</PRE>

<P>

<PRE>    chunk mode 
        my $t= new XML::Twig( TwigHandlers =&gt; { section =&gt; \&amp;flush});
        $t-&gt;parsefile( 'doc.xml');
        $t-&gt;flush;
        sub flush { $_[0]-&gt;flush; }
</PRE>

<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
This module provides a way to process XML documents. It is build on top of <EM>XML</EM>.


<P>

The module offers a tree interface to the document, while allowing to
output the parts of it that have been completely processed.


<P>

What should you use it for: xml to xml or xml to html conversions of
documents that are small enough to fit in memory, or that can be divided in
chunks that can be processed separately.


<P>

<P>
<HR>
<H1><A NAME="METHODS">METHODS

</A></H1>
<P>
<HR>
<H2><A NAME="Twigs">Twigs 

</A></H2>
A twig is a subclass of XML::Parser, so all XML::Parser methods can be used
on one, including parse and parsefile. setHandlers on the other hand should
not be used for Start, End and Char, see <CODE><A HREF="#BUGS">BUGS</A></CODE>




<P>

<DL>
<DT><STRONG><A NAME="item_new">new 

</A></STRONG><DD>
This is a class method, the constructor for XML::Twig. Options are passed
as keyword value pairs. Recognized options are the same as <EM>XML</EM>, plus some XML::Twig specifics:


<P>

<DL>
<DT><STRONG><A NAME="item__">- TwigHandlers

</A></STRONG><DD>
This argument replaces the corresponding XML::Parser argument. It consists
of a hash { gi =&gt; \&amp;handler} A gi (generic identifier I guess) is
just a tag name by the way. When an element is CLOSED the corresponding
handler is called, with 2 arguments, the twig and the <CODE><A HREF="#Element">Element</A></CODE>. The twig includes the document tree taht has been built so far, the
element is the complete sub-tree for the element. Text is stored in
elements which gi is #PCDATA (due to mixed content, text and sub-element in
an element there is no way to store the text as just an attribute of the
enclosing element).


<P>

<DT><STRONG><A NAME="item_LoadDTD">LoadDTD

</A></STRONG><DD>
If this argument is set to a true value, parse or parsefile on the twig
will load the DTD information. This information can then be accessed
through the twig, in a DTDHandler for example. This will load even an
external DTD.


<P>

See <A HREF="#DTD_Handling">DTD Handling</A> for more information


<P>

<DT><STRONG><A NAME="item_DTDHandler">DTDHandler

</A></STRONG><DD>
Sets a handler that will be called once the doctype (and the DTD) have been
loaded, with 2 arguments, the twig and the DTD.


<P>

-item StartTagHandlers


<P>

A hash { gi =&gt; \&amp;handler}. Sets element handlers that are called
when the element is open (at the end of the XML::Parser Start handler). THe
handlers are called with 2 params: the twig and the element. The element is
empty at that point, its attributes are created though.


<P>

THe main use for those handlers is probably to create temporary attributes
that will be used when processing the element with the normal TwigHanlder.  


<P>

<DT><STRONG>- Id

</A></STRONG><DD>
This optional argument gives the name of an attribute that can be used as
an ID in the document. Elements whose ID is known can be accessed through
the elt_id method. Id defaults to 'id'. See <CODE><A HREF="#BUGS">BUGS</A></CODE>




<P>

</DL>
<DT><STRONG><A NAME="item_root">root

</A></STRONG><DD>
Returns the root element of a twig


<P>

<DT><STRONG><A NAME="item_entity_list">entity_list

</A></STRONG><DD>
Returns the entity list of a twig


<P>

<DT><STRONG><A NAME="item_change_gi">change_gi      ($old_gi, $new_gi)

</A></STRONG><DD>
Performs a (very fast) global change. All elements old_gi are now new_gi.
See <CODE><A HREF="#BUGS">BUGS</A></CODE>




<P>

<DT><STRONG><A NAME="item_flush">flush            OPTIONAL_FILEHANDLE OPTIONNAL_OPTIONS

</A></STRONG><DD>
Flushes a twig up to (and including) the current element, then deletes all
unnecessary elements from the tree that's kept in memory. flush keeps track
of which elements need to be open/closed, so if you flush from handlers you
don't have to worry about anything. Just keep flushing the twig every time
you're done with a sub-tree and it will come out well-formed. After the
whole parsing don't forget to flush one more time to print the end of the
document. The doctype and entity declarations are also printed.


<P>

OPTIONNAL_OPTIONS


<P>

Use that option if you have updated the (internal) DTD and/or the enity
list and you want the updated DTD to be output 


<P>

Example $t-&gt;flush( Update_DTD =&gt; 1); $t-&gt;flush( \*FILE, Update_DTD
=&gt; 1); $t-&gt;flush( \*FILE);


<P>


flush take an optional filehandle as an argument.


<P>

<DL>
<DT><STRONG><A NAME="item_print">print            OPTIONNAL_FILEHANDLE OPTIONNAL_OPTIONS

</A></STRONG><DD>
Prints the whole document associated with the twig. To be used only AFTER
the parse.


<P>

OPTIONNAL_OPTIONS: see <EM>flush</EM>.


<P>

<DT><STRONG><A NAME="item_print_prolog">print_prolog     OPTIONNAL_FILEHANDLE OPTIONNAL_OPTIONS

</A></STRONG><DD>
Prints the prolog (XML declaration + DTD + entity declarations) of a
document.


<P>

OPTIONNAL_OPTIONS: see <EM>flush</EM>.


<P>

</DL>
<P>
<HR>
<H2><A NAME="Element">Element

</A></H2>
<DL>
<DT><STRONG>new 

</A></STRONG><DD>
Should be private.


<P>

<DT><STRONG><A NAME="item_set_gi">set_gi         ($gi)

</A></STRONG><DD>
Sets the gi of an element


<P>

<DT><STRONG><A NAME="item_gi">gi                       

</A></STRONG><DD>
Returns the gi of the element


<P>

<DT><STRONG><A NAME="item_closed">closed                   

</A></STRONG><DD>
Returns true if the element has been closed. Might be usefull if you are
somewhere in the tree, during the parse, and have no idea whether a parent
element is completely loaded or not.


<P>

<DT><STRONG><A NAME="item_set_pcdata">set_pcdata     ($text)

</A></STRONG><DD>
Sets the text of a #PCDATA element. Returns the text or undef if the
element was not a #PCDATA.


<P>

<DT><STRONG><A NAME="item_pcdata">pcdata

</A></STRONG><DD>
Returns the text of a #PCDATA element or undef


<P>

<DT><STRONG>root 

</A></STRONG><DD>
Returns the root of the twig containing the element


<P>

<DT><STRONG><A NAME="item_twig">twig 

</A></STRONG><DD>
Returns the twig containing the element. 


<P>

<DT><STRONG><A NAME="item_parent">parent        ($optional_gi)

</A></STRONG><DD>
Returns the parent of the element, or the first ancestor whose gi is $gi.


<P>

<DT><STRONG><A NAME="item_first_child">first_child   ($optional_gi)

</A></STRONG><DD>
Returns the first child of the element, or the first child whose gi is $gi.
(ie the first of the element children whose gi matches) .


<P>

<DT><STRONG><A NAME="item_last_child">last_child    ($optional_gi)

</A></STRONG><DD>
Returns the last child of the element, or the last child whose gi is $gi.
(ie the last of the element children whose gi matches) .


<P>

<DT><STRONG><A NAME="item_prev_sibling">prev_sibling  ($optional_gi)

</A></STRONG><DD>
Returns the previous sibling of the element, or the first one whose gi is
$gi. 


<P>

<DT><STRONG><A NAME="item_next_sibling">next_sibling  ($optional_gi)

</A></STRONG><DD>
Returns the next sibling of the element, or the first one whose gi is $gi. 


<P>

<DT><STRONG><A NAME="item_atts">atts

</A></STRONG><DD>
Returns a hash ref containing the element attributes


<P>

<DT><STRONG><A NAME="item_set_atts">set_atts      ({att1=>$att1_val, att2=> $att2_val... )

</A></STRONG><DD>
Sets the element attributes with the hash supplied as argument


<P>

<DT><STRONG><A NAME="item_del_atts">del_atts

</A></STRONG><DD>
Deletes all the element attributes.


<P>

<DT><STRONG><A NAME="item_set_att">set_att      ($att, $att_value)

</A></STRONG><DD>
Sets the attribute of the element to a value


<P>

<DT><STRONG><A NAME="item_att">att          ($att)

</A></STRONG><DD>
Returns the attribute value


<P>

<DT><STRONG><A NAME="item_del_att">del_att { delete $_[0]->{'att'}->{$_[1]}; }

</A></STRONG><DD>
Delete the attribute for the element


<P>

<DT><STRONG><A NAME="item_set_id">set_id       ($id)

</A></STRONG><DD>
Sets the id attribute of the element to a value. See <CODE><A HREF="#elt_id">elt_id</A></CODE> to change the id attribute name


<P>

<DT><STRONG><A NAME="item_id">id

</A></STRONG><DD>
Gets the id attribute vakue


<P>

<DT><STRONG><A NAME="item_children">children     ($optional_gi)

</A></STRONG><DD>
Returns the list of children (optionally whose gi is $gi) of the element


<P>

<DT><STRONG><A NAME="item_ancestors">ancestors    ($optional_gi)

</A></STRONG><DD>
Returns the list of ancestors (optionally whose gi is $gi) of the element


<P>

<DT><STRONG><A NAME="item_next_elt">next_elt     ($optional_gi)

</A></STRONG><DD>
Returns the next elt (optionally whose gi is $gi) of the element. This is
defined as the next element which opens after the current element opens.
Which usually means the first child of the element. Counter-intuitive as it
might look this allows you to loop through the whole document by starting
from the root.


<P>

<DT><STRONG><A NAME="item_prev_elt">prev_elt     ($optional_gi)

</A></STRONG><DD>
Returns the previous elt (optionally whose gi is $gi) of the element. This
is the first element which open the current one. So it's usually either the
last descendant of the previous sibling or simply the parent


<P>

<DT><STRONG><A NAME="item_level">level       ($optionnal_gi)

</A></STRONG><DD>
Returns the depth of the element in the tree (root is 1) If the optionnal
gi is given then only ancestors of the given type are counted 


<P>

<DT><STRONG><A NAME="item_in">in           ($potential_parent)

</A></STRONG><DD>
Returns true if the element is in the potential_parent


<P>

<DT><STRONG><A NAME="item_in_context">in_context   ($gi, $optional_level)

</A></STRONG><DD>
Returns true if the element is included in an element whose gi is $gi,
within <A HREF="#item__level">$level</A> levels.


<P>

<DT><STRONG><A NAME="item_cut">cut

</A></STRONG><DD>
Cuts the element from the tree.


<P>

<DT><STRONG><A NAME="item_paste">paste       ($optional_position, $ref)

</A></STRONG><DD>
Pastes a (previously cut) element. The optionnal position element can be


<P>

<DL>
<DT><STRONG>- first_child (default)

</A></STRONG><DD>
The element is pasted as the first child of the <CODE>$ref</CODE> element


<P>

<DT><STRONG>- last_child

</A></STRONG><DD>
The element is pasted as the last child of the <CODE>$ref</CODE> element


<P>

<DT><STRONG>- before

</A></STRONG><DD>
The element is pasted before the <CODE>$ref</CODE> element, as its previous
sibling


<P>

<DT><STRONG>- after

</A></STRONG><DD>
The element is pasted after the <CODE>$ref</CODE> element, as its next
sibling


<P>

</DL>
<DT><STRONG><A NAME="item_erase">erase

</A></STRONG><DD>
Erases the element: the element is deleted and all of its children are
pasted in its place.


<P>

<DT><STRONG><A NAME="item_delete">delete

</A></STRONG><DD>
Cut the element and frees the memory


<P>

<DT><STRONG><A NAME="item_DESTROY">DESTROY

</A></STRONG><DD>
Frees the element from memory 


<P>

<DT><STRONG><A NAME="item_start_tag">start_tag

</A></STRONG><DD>
Returns the string for the start tag for the element, including the /&gt;
at the end of an empty element tag


<P>

<DT><STRONG><A NAME="item_end_tag">end_tag

</A></STRONG><DD>
Returns the string for the end tag of an element, empty for an empty one.


<P>

<DT><STRONG>print         OPTIONNAL_FILEHANDLE

</A></STRONG><DD>
Prints an entire element, including the tags, optionally to a FILEHANDLE     


<P>

<DT><STRONG><A NAME="item_sprint">sprint  

</A></STRONG><DD>
Returns the string for an entire element, including the tags. To be used
with caution!


<P>

<DT><STRONG><A NAME="item_text">text

</A></STRONG><DD>
Returns a string consisting of all the PCDATA in an element, without the
tagging


<P>

<DT><STRONG><A NAME="item_set_text">set_text        ($string)

</A></STRONG><DD>
Sets the text for the element: if the element is a PCDATA, just set its
text, otherwise cut all the children of the element and create a single
PCDATA child for it, which holds the text


<P>

<DT><STRONG><A NAME="item_set_content">set_content    (@list_of_elt_and_strings)

</A></STRONG><DD>
Sets the content for the element, from as list of strings and elements.
Cuts all the element children, then pastes the list elements, creating a
PCDATA element for strings.


<P>

<DT><STRONG><A NAME="item_private">private methods

</A></STRONG><DD>
<DL>
<DT><STRONG><A NAME="item_close">close

</A></STRONG><DD>
<DT><STRONG><A NAME="item_set_parent">set_parent        ( $parent)

</A></STRONG><DD>
<DT><STRONG><A NAME="item_set_first_child">set_first_child   ( $first_child)

</A></STRONG><DD>
<DT><STRONG><A NAME="item_set_last_child">set_last_child    ( $last_child)

</A></STRONG><DD>
<DT><STRONG><A NAME="item_set_prev_sibling">set_prev_sibling  ( $set_prev_sibling)

</A></STRONG><DD>
<DT><STRONG><A NAME="item_set_next_sibling">set_next_sibling  ( $set_next_sibling)

</A></STRONG><DD>
<DT><STRONG><A NAME="item_flushed">flushed

</A></STRONG><DD>
<DT><STRONG>flush

</A></STRONG><DD>
</DL>
Those methods should not be used, unless of course you find some creative
and interesting, not to mention usefull, ways to do it.


<P>

</DL>
<P>
<HR>
<H2><A NAME="Entity_list">Entity_list

</A></H2>
<DL>
<DT><STRONG>new

</A></STRONG><DD>
Creates an entity list


<P>

<DT><STRONG><A NAME="item_add">add         ($ent)

</A></STRONG><DD>
Adds an entity to an entity list.


<P>

<DT><STRONG>delete     ($ent or $gi).

</A></STRONG><DD>
Deletes an entity (defined by its name or by the Entity object) from the
list.


<P>

<DT><STRONG>print      (OPTIONAL_FILEHANDLE)

</A></STRONG><DD>
Prints the entity list


<P>

</DL>
<P>
<HR>
<H2><A NAME="Entity">Entity

</A></H2>
<DL>
<DT><STRONG>new        ($name, $val, $sysid, $pubid, $ndata)

</A></STRONG><DD>
Same arguments has the Entity handler for XML::Parser


<P>

<DT><STRONG>print       (OPTIONNAL_FILEHANDLE)

</A></STRONG><DD>
Prints an entity declaration


<P>

<DT><STRONG>text

</A></STRONG><DD>
Returns the entity declaration text


<P>

</DL>
<P>
<HR>
<H1><A NAME="EXAMPLES">EXAMPLES

</A></H1>
See the test file in XML-Twig-1.6/t/test[1-n].t 


<P>

To figure out what flush does call the following script with an xml file
and an element name as arguments


<P>

use XML::Twig;


<P>

my ($file, $elt)= @ARGV; my $t= new XML::Twig( TwigHandlers =&gt; {
<CODE>$elt</CODE> =&gt; sub {$_[0]-&gt;flush; print ``\n[flushed
here]\n'';} }); $t-&gt;parsefile( $file, ErrorContext =&gt; 2);
$t-&gt;flush; print ``\n'';


<P>

<P>
<HR>
<H1><A NAME="NOTES">NOTES

</A></H1>
<P>
<HR>
<H2><A NAME="DTD_Handling">DTD Handling

</A></H2>
3 possibilities here


<P>

<DL>
<DT><STRONG><A NAME="item_No">No DTD

</A></STRONG><DD>
No doctype, no DTD information, no entitiy information, the world is
simple...


<P>

<DT><STRONG><A NAME="item_Internal">Internal DTD

</A></STRONG><DD>
The XML document includes an internal DTD, and maybe entity declarations


<P>

If you use the TwigLoadDTD when creating the twig the DTD information and
the entity declarations can be accessed. 


<P>

The DTD and the entity declarations will be flush'ed (or print'ed) either
asis (if they have not been modified) or as reconstructed (poorly, comments
are lost, order is not kept, due to it's content this DTD should not be
viewed bu anyone) if they have been modified. You can also modify them
directly by changing the $twig-&gt;{twig_doctype}-&gt;{internal} field
(straight from XML::Parser, see the Doctype handler doc)


<P>

<DT><STRONG><A NAME="item_External">External DTD

</A></STRONG><DD>
The XML document includes a reference to an external DTD, and maybe entity
declarations.


<P>

If you use the TwigLoadDTD when creating the twig the DTD information and
the entity declarations can be accessed. The entity declarations will be
flush'ed (or print'ed) either asis (if they have not been modified) or as
reconstructed (badly, comments are lost, order is not kept).


<P>

You can change the doctype through the $twig-&gt;set_doctype method and
print the dtd through the $twig-&gt;dtd_text or $twig-&gt;dtd_print
methods.


<P>

If you need to modify the entity list this is probably the easiest way to
do it.


<P>

</DL>
<P>
<HR>
<H2><A NAME="Whitespace_Handling">Whitespace Handling

</A></H2>
If an element contains ONLY whitespaces (as in the regexp \s), then
XML::Twig does not generate a PCDATA child for this element.


<P>

This can bite you if you are interested in the white spaces included in
some elements. This could be improved in a future version, through a
general option that processes all spaces, or by giving a list of elements
for which whitespaces are to be processed. Let me know what your
requirements are!


<P>

<P>
<HR>
<H2><A NAME="Flush">Flush

</A></H2>
If you set handlers and use flush, do not forget to flush the twig one last
time AFTER the parsing, or you might be missing the end of the document.


<P>

Remember that element handlers are called when the element is CLOSED, so if
you have handlers for nested elements the inner handlers will be called
first. It makes it for example trickier than it would seem to number nested
clauses.


<P>

<P>
<HR>
<H1><A NAME="BUGS">BUGS

</A></H1>
<DL>
<DT><STRONG>- ID list

</A></STRONG><DD>
The ID list is NOT updated at the moment when ID's are modified or elements
cut or deleted.


<P>

<DT><STRONG>- change_gi

</A></STRONG><DD>
Does not work if you do: $twig-&gt;change_gi( $old1, $new);
$twig-&gt;change_gi( $old2, $new); $twig-&gt;change_gi( $new, $even_newer);


<P>

<DT><STRONG>- sanity check on XML::Parser method calls

</A></STRONG><DD>
XML::Twig should really prevent calls to some XML::Parser methods,
especially the setHandlers one.


<P>

<DT><STRONG>- Notation declarations

</A></STRONG><DD>
Are not output (in fact they are completely ignored).


<P>

</DL>
<P>
<HR>
<H1><A NAME="TODO">TODO 

</A></H1>
<DL>
<DT><STRONG>- multiple twigs are not well supported

</A></STRONG><DD>
A number of twig features are just global at the moment. These include the
ID list and the ``gi pool'' (if you use change_gi then you change the gi
for ALL twigs).


<P>

Next version will try to support these while trying not to be to hard on
performances (at least when a single twig is used!).  


<P>

<DT><STRONG>- XML::Parser-like handlers

</A></STRONG><DD>
Sometimes it would be nice to be able to use both XML::Twig handlers and
XML::Parser handlers, for example to perform generic tasks on all open
tags, like adding an ID, or taking care of the autonumbering.


<P>

Next version...


<P>

<DT><STRONG>- create an element (not a twig) from a string.

</A></STRONG><DD>
</DL>
<P>
<HR>
<H1><A NAME="BENCHMARKS">BENCHMARKS

</A></H1>
You can use the <CODE>benchmark</CODE> file to do additional bechmarks. Please send me bechmark information for
additional systems.


<P>

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>
Michel Rodriguez <A
HREF="MAILTO:<m.v.rodriguez@ieee.org>"><m.v.rodriguez@ieee.org></A>


<P>

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


<P>

Bug reports and comments to <A
HREF="MAILTO:m.v.rodriguez@ieee.org.">m.v.rodriguez@ieee.org.</A>


<P>

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO

</A></H1>
<EM>XML</EM>




<P>

</DL>
    </BODY>

    </HTML>
